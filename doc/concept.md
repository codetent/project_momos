

# Introduction

## Implementation Testing

## Test Case Selection

## Protocols

TODO: what

## gPTP

## Protocol Structures

TODO: why protocol = state machine

## State Machines

A state machine describes the behavior of a model. This concept focuses on finite state machines which are state machines containing only a finite number of reachable states.
In short, the states are known in advance and the overall amount does not change over time.

As state machines can be represented as graphs, the paper focuses only on the graphical representation called stated graphs. Such graphs consists of nodes and edges called states and transitions in this context. All the transitions connect two states with a top-down direction. Therefore, the graph is called directed graph. For simplifying the graphs, all transitions are only unidirectional. If a state shall be connected with its predecessor, a new transition have to be created. The advantage of using the graph form is that graph theory can be applied. This is a mathemathical subject covers many algorithms and formulas. It especially gained attentation in the last years in the sector of machine learning where nearly all agorithms are based on this theory. 

The connections between the states, called transitions, are coupled with an action. If the specified action occurs, one state transitions into another one. If there is no action, the system the current state remains the same. This demonstrates the storing capability of a state machine. It is also possible that a transition ends into the same state it is arisen from. This pattern is called cycle and is present in the most state machines. Cycles are problematic because they make it hard to predict the exact behavior especially regarding timing.

A collection of states and their transitions ordered by there occurence is called path. Paths describe the traversable ways through the state machine. If there are cycles, the count of all paths is infinite because it is possible that a feedback transition is traversed multiple times. A simple state machine is a special case without any loops which contains a finite amount of paths. As cycles are a common element in normal state machines, the processing is done using simple paths. This special type of path does not contain any loop and is therefore much easier to process. Additionally, omitting the loops does not change the behavior of the state graph any further because a loop in a path is only executing some actions multiple times.

## Graph Representations

State graphs can be created using various graphical tools or code based:

Graphical tools are especially usefull for creating state graphs from scratch or easily documenting previously existing state machines.

TODO: graphical tools

Code based approaches are typically used for creating graphics in various formats or processing them further for any other purpose. The advantage compared to graphical tools is that this process can be automated. Additionally, the output is not depending on the user of a tool, but rather it is deterministic. In general, all tools for creating graphs can be utilized for this application.

One of the most famous visual programming languages is the Unified Modelling Language (UML) based on XML. It provides various graph types for documenting software components, their composition or algorithms. UML state charts are a diagram type especially created for finite state machines. These charts are focusing on an event-driven software flow: it waits for an event, dispatches it and after consuming it, it waits again for the next event. It visualized directed graphs using states, called nodes, and transition arrows denoted by connectors. In addition, two other elements are available: guards and actions. Transitions with guard conditions can only be traversed if the expressions evaluates to true. Actions are the reaction to an event like calling functions or changing to another state. [\[1\]](https://en.wikipedia.org/wiki/UML_state_machine)

The DOT language was created for visualizing structural information as abstract graphs. It is not based on any existing language like UML, but rather it comes with its own domain specific language. Usually, these graphs are automatically generated by documentation tools like doxygen. The advantage over UML is that the DSL is simpler and shorter than writing graphs in XML. So they can even be written manually as code without any further effort. DOT supports various graph models like directed and unidrected graphs and is not only limited to state machines. Additionally, the styling can be changed by modifying node or edge attributes. Different tools like Graphviz or various libraries for many programming languages implement this language and allow generting such rendered graphs.

There are also other visual languages like DOT but especially designed for state machines. State Machine cat is one if them. In general, it is a simplified version of DOT without depending on Graphviz tools. The code primarily declares transitions and the states are automatically generated. Compared to DOT the user must not define graph types or the structure typically used for state graphs because this is done by the language itself. [\[3\]](https://github.com/sverweij/state-machine-cat)

## Code Documentation

Documentiation is crucial for developing understandable and maintainable software. In the most cases, good documentation is very rare and even some companies rely on the code only instead of having an explicit documentation unter the motto "our code is our documentation". But in short: "every engineer is also a writer" [\[4\]](https://developers.google.com/tech-writing) because a product or software component is useless if they target audience does not know how to use it.

The required documents depend on the product and the targeted audience. A software component shall be shipped with an user guide describing the main concepts and how it can be integrated in another project. References are representing the existing interface and all the inputs and the resulting outputs. If the product is a user application, the reference is usually ommitted and the user guide contains the descriptions of the software.

When developing software, the main focus is on the implementation work. Writing guides is in the most cases not preferred by developers and therefore not much time is spent on it. Some companies are employing technical writers but as they are not the creator of a product, their insight or technical knowledge is limited.

To lower the barriers for developers getting a good documentation, the state-of-the-art way is generating one from existing documents, for example source code. Generation is usually done through adding annotations (mostly using comments) to the implementation which are then parsed and converted to a human-readable format like a PDF document. Additionally, modern tools support creating graphs of the components that are integrated into the result. If the documentation contains examples, which is highly preferred, these can also be automatically checked against their proper functioning.

## Documentation Problems

## State of the Art

# Concept

## Graph Definition

## Graph Structure

## Test Structure

## Flow
